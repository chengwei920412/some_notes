# GAIM

- 首先resize图片到1000像素对角线长度.(3000×4000resize到了600×800的大小)
- 获取灰度图.
- 在图像中提取特征点.(GAIM_compFeatData()函数)
  - 调用GAIM_doSimulation()函数.
    - 根据剪切系数和尺度系数构造一个仿射矩阵(3×3的矩阵$A​$),然后根据构造的矩阵将图像进行变换.(因为生成的图像的大小和之前的不一样了,所以$A​$矩阵也变换为3×3的矩阵了,加上了translation到1,3和2,3位置.生成的矩阵为$Awarp​$矩阵,计算出$Awarp​$矩阵的逆矩阵$AwarpInv​$矩阵)
    - 调用GAIM_extractImgFeatures()函数提取变换后的图像$imWarped\_b​$上的特征.根据特征点的旋转,尺度和位置信息构建一个仿射变换矩阵$AAnpd​$.
    - 然后根据$Awarp$矩阵和$AAnpd$矩阵可以计算出原来的未变换图像的仿射变换矩阵$AAnpd\_origImg =AwarpInv*AAnpd$
    - 再根据$AwarpInv$计算特征点在原图像上的位置.
    - 遍历上面的步骤,根据剪切系数和尺度系数的不同构造不同的$Featdata​$.
    - 然后将所有的$Featdata$数据构造成一个数据$F$.
  - 将$F$中的数据存入$/GxFeats.mat$中.
  - 调用GAIM_extractImgFeatures()函数提取原本图像上的特征点信息$Featdata$.
  - 消除重复的特征点.
  - 将原本图像上的特征点信息$Featdata​$传入$F​$中,将$F​$中的数据存入$/GlFeats.mat​$中.
- 读取$/GxFeats.mat​$中的数据到$GxFeats1​$和$GxFeats2​$中,读取$/GlFeats.mat​$中的数据到中$GlFeats2​$.($GlFeats​$中存的数据都是原本图像上的数据,而$GxFeats​$中存的数据是变换后的图像数据)
- 对于第二个图像上的点,在第一个图像上(传进去的是$GxFeats1$,也就是说找到的特征点也是变换后的图像上的特征点)找出$k$个最近的特征点($LS$是N×K的矩阵,代表匹配的特征点的index,$D$也是N×K的矩阵,代表匹配的特征点的距离).
- 在第二帧图像中,根据特征点的位置信息组成一个graph.
  - 对每一个特征点在第二帧图像中找到35个最近的点.
  - 然后将这个信息组成一个n×n的矩阵$A​$.
  - 计算公式$A=(A+A^T)>0$.(这里为什么需要计算这个公式是因为为了在后面计算graph边数好计算,只要除一个2就行了.)
- 求解MRF公式.
  - 首先将graph构成图的形式,调用UGM_makeEdgeVE()函数.获得$V,E​$,$E​$代表连接该特征点的edge的ID,是一个向量,$V(i)​$代表到第$i-1​$个node总共连接的edge数量.
  - 调用GAIM_edgePotential()函数.(因为这个graph是根据第二帧图像建立的,所以都要在第二帧图像上找点)
    - 遍历上面获得的edge.
    - 选取一个$edgePoints$,找出这个edge对应特征点$p\_i,p\_j$,获取这两个特征点之间的空间距离$d0$.
    - 获取两个点计算的仿射变换矩阵$AApnd\_origImg$.(这一步提取的是原本图像上的特征点)
    - 求取两个点的仿射变换矩阵的逆矩阵$Aimg1inv,Aimg2inv$.
    - 获取两个点与第一帧图像的最近的50个匹配点的index:$index1\_F1s,index2\_F1s​$.
    - 获取$index1\_F1s$和$index2\_F1s$的仿射变换矩阵的转置$AAnpds\_origImgT$
    - 然后让这些仿射变换矩阵的转置先转置再组成一个150×3的矩阵$AS1,AS2$.(还不如直接提取未转置的矩阵!!!!!)
    - 让$AS1$与$Aimg1inv$相乘,$AS2$与$Aimg2inv$相乘获得$Aimg2Template$.
    - 获得第一帧图像中$index1\_F1s,index2\_F1s$的位置$q\_is,q\_js$,让$Aimg2Template$与$p\_i,p\_j$相乘获得预测的位置$q\_iPred,q\_jPred$.
    - 计算预测位置和所有实际位置的距离,最终形成两个50×50的矩阵$d1,d2$.(之所以要计算所有点之间的距离,则是因为我们是用边来表示的,自然要选择边,所以要选择两个点,那么这其中任意两个点都有可能)
    - 找出$d1,d2$中对应位置最小的值形成一个矩阵$costValue$.
    - $costValue$除以$d0$.
    - 计算$q\_is,q\_js$之间的距离,也形成一个50×50的矩阵.如果这个矩阵中有值为0的话,那么就认为有两个点其实是一个点,那么在$costValue$中设置相应的位置值为最大值$GAIM\_LARGE$.(因为我们要选择两个点,那么这两个点是一个点的话,明显不可能使我们所需要的两个点)
    - 将所有edge的$costValue​$组成$edgeCosts​$,并且设置其中大于0.4和小于最大值$GAIM\_LARGE​$的位置设为0.4.
  - 调用MRF_solveAlphaExpansion方法.
    - 在$D$中随机选取一列(总共有50列(取多少最相邻的特征点就有多少列))$Ue2$,然后取第一列$Ue1$,组成$UE$,$L0,L1$代表要取值的列数,是50×1的向量.(为什么只取两列是因为graph-cut没有处理一个点连接多个edge的能力,这里只能两两列进行比较,最后还是会取满50列.)
    - 得到几个$edgeCosts$值,$v1$是第($L0(PI(1,1:edge)),L0(PI(2,1:edge)),[1:edge]$)的值,组成一个edge数×1的向量.同理,$v2$是第($L0(PI(1,1:edge)),L1(PI(2,1:edge)),[1:edge]$)的值,$v3$是第($L1(PI(1,1:edge)),L0(PI(2,1:edge)),[1:edge]$)的值,$v4$是第($L1(PI(1,1:edge)),L1(PI(2,1:edge)),[1:edge]$)的值.($v1$相当于去除所有的)
    - $q1$是第($L0(PI(2,1:edge)),L0(PI(1,1:edge)),[1:edge]$)的值,$q2$是第($L0(PI(2,1:edge)),L0(PI(1,1:edge)),[1:edge]$)的值,$q3$是第($L0(PI(2,1:edge)),L0(PI(1,1:edge)),[1:edge]$)的值,$q4$是第($L0(PI(2,1:edge)),L0(PI(1,1:edge)),[1:edge]$)的值.
    - 将$v1,v2,v3,v4,q1,q2,q3,q4$组成$PE$.
    - 构建一个graph,节点数目为$UE​$的列数,也就是当前帧提取的特征点的数目.
    - 在graph中创造所有点的空间.
    - 将顶点的costValue放入graph中,值为$UE$中的值,第一行为E0,第二行为E1.(这里面的E0,E1就是当前帧上的特征点和参考帧进行变换后的图像上的多个特征点进行匹配的描述子的距离.)
    - 将顶点之间的costValue放入graph中,值为$PE$的值,第一行为E00,第二行为E01,第三行为E10,第四行为E11.
