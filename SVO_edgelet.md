[TOC]

# SVO_edgelet

### 参数

---

```c++
trace_name("svo"),
trace_dir("/tmp"),
n_pyr_levels(3), //3
use_imu(false),
core_n_kfs(3),
map_scale(1.0),
grid_size(25),                    // 75
init_min_disparity(50.0),
init_min_tracked(50),
init_min_inliers(40),
klt_max_level(4), // 4      //6
klt_min_level(2),  // 2      //4
reproj_thresh(2.0),  // 2  //6.0
poseoptim_thresh(2.0),
poseoptim_num_iter(10),
structureoptim_max_pts(20),
structureoptim_num_iter(5),
loba_thresh(2.0),
loba_robust_huber_width(1.0),
loba_num_iter(0),
kfselect_mindist(0.12),   // 0.12
triang_min_corner_score(5.0),   // 20
triang_half_patch_size(4),
subpix_n_iter(10),
max_n_kfs(30),   // 10
img_imu_delay(0.0),
max_fts(180),    //120
quality_min_fts(30),  //50   //20
quality_max_drop_fts(40)
```

## 变量定义

n_matches_ 多少个块匹配
n_trails_在reprojectCell中体现,重投影了多少特征点



### 创新点

- 在Tracking的时候，直接由参考帧图像上的特征点延伸到三维空间中对应的地图点深度一样的位置，然后投影到当前帧。而不是地图点，因为地图点经过优化后与特征点投影到三维空间中的点也有误差。这就保证了要投影的图块的准确性。 延伸出来的空间点肯定也与特征点以及光心在一条直线上。
- 以当前帧上的投影点的像素值为基准，通过优化调整参考帧投影过来的像素点的位置，以此来优化这两者像素值参差。这样，投影过来的图块patch上的像素值关于像素点位置的雅克比，就可以提前计算并且固定了。（而以前普通的方法是，以参考帧投影过去的像素值为基准，通过优化投影点的位置，来优化这两者的残差。）



### 初始化

---

- 传入第一张图片，构建金字塔，每一层的图像就是上一层邻近四个像素的线性加权。之后检测Fast特征点和Edge特征点，如果中间特征点大于50个，则认为是关键帧。

  - 在检测FAST角点的时候，每个grid里面只会有一个相应的点，然后判断这个点的分数是否可以视为一个特征点。
  - 之后检测edgelet特征。如果在这个grid 有特征点特征，那么则不需要检测edgelet，如果没有则检测edgelet特征。
    - edgelet特征是要判断是否在canny检测出的线上，如果在线上才能判断是线特征，把这个最大响应的点存入进去。
    - 如果特征点数量不够，则也会把max grad point存入每一个grid里面。
    - edgelet特征只检测第0层金字塔。
  - 如果图像总特征点数目大于100个且图像中间（[1/4, 3/4]）的特征点的数目大于50个，就把这一帧当做关键帧。

- 之后处理第一帧之后的图像，进行KLT光流跟踪，将特征像素点转化为在相机归一化平面上的点，进行去畸变矫正。

- 要求匹配的点数大于阈值，并且匹配点的视差中位数大于阈值。如果视差的方差大的话，选择计算E矩阵，如果视差的方差小的话，选择计算H矩阵。如果计算完H或E后，还有足够的内点，就认为这帧是合适的用来三角化的帧。根据H或E恢复出来的位姿和地图点，进行尺度变换，把深度的中值调为1。

- 然后把这一帧，作为关键帧，送入到深度滤波器中（即updateSeedsLoop函数）。

  - 新的关键帧到来，则中断updateSeeds函数因为这时有很大可能正在处理普通帧，而不是关键帧，所以就丢掉了，即，关键帧优先。
  - 如果传进来的帧是关键帧，则updateSeeds之后还需要初始化种子。
    - 在初始化种子时，第二帧图像上的feature是由第一帧图像匹配而来，所以不需要通过深度滤波器进行优化了。
    - 然后检测新的特征，加入到seeds_中，如果在新检测到的特征点有离匹配到的feature近（dist_min=70）的话，那么就把这个特征点的种子深度值设为近的特征点的深度值，不然就设置为平均深度值。


### 基于稀疏点亮度的位姿估计

---

- 在初始化后，新来一帧图像，则将上一帧图像的位姿赋给这个图像，相当于优化的位姿初值是上一帧的位姿，求当前帧相当于上一帧的位姿。
  - 创建n行16列的矩阵，ref_patch_cache_，n代表参考帧上面的特征点的个数，16代表要取的特征patch的像素数量，在这个矩阵中，每一行存的是每一个特征点那一块的双线性插值的数值。
  - 再创建6行n*16列的矩阵，jacobian_cache_，每一个特征patch的每个像素对应一个６×1的雅克比，因为是图块上的雅克比矩阵，所以还要考虑图块的梯度。
  - 接着，从当前帧金字塔最高层开始进行调用optimize()函数。把参考帧上的所有图块结合地图点，往当前帧图像的金字塔图像上投影。（因为投影过来的点的坐标肯定是小数，所以就需要双线性插值）在当前帧的金字塔图像上，从最高层开始，一层层往低层算。每次继承前一次的优化结果。如果前一次的误差相比前前次没有减小的话，就继承前前次的优化后的位姿。每层的优化，迭代30次。
    - 在这个optimize()函数中，我们首先要计算两帧之间的patch的参差。在计算残差的时候，我们要计算根据双线性插值计算参考帧上的特征点投影到当前帧上的特征点的位置，然后计算平均残差平方和。接着计算Ｈ矩阵和Jres矩阵(J×b)，这些矩阵都是所有特征patch算出的矩阵累加得到的。
    - 然后求解优化方程，如果出现问题，或者误差上升，则正面上一次模型是最优的，输出上一轮迭代得到的模型。
    - 计算出迭代增量，更新模型。
    - 如果算出来的增量过小，则也退出优化。
- 使用上一时刻求出的初始值，对每个当前帧能观察到的地图点p（已经收敛的深度估计），找到观察p角度最小的关键帧上的对应点，优化得到p在当前帧上的投影。（这一步是通过局部地图对当前帧进行优化，因为虽然上一帧能看到的地图点和当前帧已经重合大部分，但仍有一部分当前帧能看到的视野，而上一帧看不到，所以我们要找到其他当前帧有视野重叠的关键帧。这些帧称为局部关键帧，其看到的地图点称为局部地图点）
  - 接下来找到与当前帧有相关视野最靠近的N个关键帧。
  - 得到与当前帧有重叠视野的所有关键帧。（就是判断关键帧上的特征点在当前帧能否观测到）
  - 根据靠近程度进行排序。（相关程度就是当前帧和关键帧之间平移向量差的二范数）
  - 对最近的N个关键帧进行迭代，找到具有重叠视野的关键帧。
    - 将关键帧的debug_img设为关键帧图像。
    - 遍历关键帧的特征点，根据特征点找到对应的地图点，再投影到当前帧。
      - 检测这个特征点是否有分配的地图点。
      - 确保只投影一次，不同帧上的特征会对应同一个3D点。
      - 如果关键帧的一个特征点在当前帧中投影成功，计数+1（reprojectPoint函数）。
        - 判断8×8的patch是否在那个帧内。
        - 如果判定这个patch在一个cell内，则在对应的cell内增加候选点。
    - 判断还未插入关键帧上的在地图上的candidate点是否可以投影上，如果一直都投影不上，说明这个点可能有问题，删除这个点。（将上面这些点都放入grid的cell里面，然后后面特征块匹配是匹配这里面的点）
    - 特征块匹配。如果匹配数量过多（180），则退出匹配。（这里面为了随机匹配，则将cell_order赋予随机数）（如果这个cell有一个candidate点能够投影，则认为这个cell可以投影）
      - 按照点的质量排序。
      - 通过光流法估计patch的位置。
        - 计算当前帧与观测到该特征中视角最小的一帧中的特征为ref_ftr_。
        - 判断该特征是否在图像内部。
        - 通过特征点和u方向和v方向的边界点计算仿射矩阵。
        - 计算该特征patch从当前帧到参考帧的仿射变换。
        - 给patch赋值。（上面计算特征patch从当前帧到参考帧的仿射变换是带border的）
        - 特征对齐。（线特征1D对齐，点特征2D对齐）
          - 计算梯度和hessian矩阵。
          - 迭代优化特征（线特征和点特征）的位置。
      - 遍历这个patch中的candidate点，如果光流法没有找到，则要删除这个candidate点，如果在这个cell中，candidate点有15个没找到，则在map里面删除这个点，candidate点有20个没找到，则在map的point_candidate里面删除这个点。
      - 如果candidate点成功投影10次，则认为这个点是GOOD点。
      - 如果candidate点能找到，则将这个点初始化为feature放入当前帧。
- 进行判断，如果匹配到的特征数小于阈值，则打印没有匹配到足够的特征信息，同时设置当前帧变换矩阵为上帧变换矩阵，设置tracking_quality为TRACKING_INSUFFICIENT，并返回RESULT_FAILURE。
- 用高斯牛顿法优化位姿。（根据投影误差丢掉一些误差大的特征点，最后留下来进行位姿优化的这些特征点被变量sfba_n_edges_final记录下来）